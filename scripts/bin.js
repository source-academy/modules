import{Command as dr}from"@commander-js/extra-typings";import{Command as Vt}from"@commander-js/extra-typings";import{Option as wt}from"@commander-js/extra-typings";import bt from"fs/promises";async function D(e){try{let t=await bt.readFile(e,"utf-8");return JSON.parse(t)}catch(t){throw t.code==="ENOENT"?new Error(`Could not locate manifest file at ${e}`):t}}var S=class extends wt{default(t,r){return super.default(t,r)}},h=new S("--srcDir <srcDir>","Location of the source files").default("src"),U=new S("--outDir <outDir>","Location of output directory").default("build"),P=new S("--manifest <manifest>","Location of manifest").default("modules.json"),We=new S("--lint","Run ESLint"),ce=new S("--fix","Fix automatically fixable linting errors").implies({lint:!0}),O=new S("-b, --bundles <bundles...>","Manually specify which bundles").default(null),L=new S("-t, --tabs <tabs...>","Manually specify which tabs").default(null);function p(...e){return Promise.all(e)}function z(e){return async(...t)=>{let r=performance.now();return{result:await e(...t),elapsed:performance.now()-r}}}function Je(e){return Object.entries(e)}var k=async(e,t,r,n=!0)=>{let i=await D(e),o=Object.keys(i),s=Object.values(i).flatMap(f=>f.tabs),a=[],d=[],l=f=>f==null;function b(){let f=t.filter(N=>!o.includes(N));if(f.length>0)throw new Error(`Unknown bundles: ${f.join(", ")}`);a=a.concat(t),n&&(d=[...d,...t.flatMap(N=>i[N].tabs)])}function m(){let f=r.filter(N=>!s.includes(N));if(f.length>0)throw new Error(`Unknown tabs: ${f.join(", ")}`);d=d.concat(r)}function x(){a=a.concat(o)}function $(){d=d.concat(s)}return l(t)&&l(r)?(x(),$()):(t!==null&&b(),r!==null&&m()),{bundles:[...new Set(a)],tabs:[...new Set(d)],modulesSpecified:!l(t)}};async function Ue(e,t){let r=await D(e),n=Object.keys(r);if(t===null)return{bundles:n,modulesSpecified:!1};let i=t.filter(o=>!n.includes(o));if(i.length>0)throw new Error(`Unknown bundles: ${i.join(", ")}`);return{bundles:[...new Set(t)],modulesSpecified:!0}}async function ze(e,t){let r=await D(e),n=Object.values(r).flatMap(o=>o.tabs);if(t===null)return{tabs:n};let i=t.filter(o=>!n.includes(o));if(i.length>0)throw new Error(`Unknown tabs: ${i.join(", ")}`);return{tabs:[...new Set(t)]}}import{copyFile as Ct}from"fs/promises";import{Command as $t}from"@commander-js/extra-typings";import c from"chalk";import{Table as Pt}from"console-table-printer";import{Command as xt}from"@commander-js/extra-typings";import Y from"chalk";import*as de from"typedoc";async function j(e,t,r,n){let i=await de.Application.bootstrap({categorizeByGroup:!0,entryPoints:A(t,e),excludeInternal:!0,logLevel:r?"Info":"Error",name:"Source Academy Modules",readme:"./scripts/src/build/docs/docsreadme.md",tsconfig:`${t}/tsconfig.json`,skipErrorChecking:!0,preserveWatchOutput:n},[new de.TSConfigReader]);if(n)return[null,i];let o=await i.convert();if(!o)throw new Error("Failed to initialize typedoc - Make sure to check that the source files have no compilation errors!");return[o,i]}var ee=z(async(e,t,[r,n])=>{if(e.modulesSpecified)return{severity:"warn",error:"Not all modules were built, skipping building HTML documentation"};try{return await n.generateDocs(r,`${t}/documentation`),{severity:"success"}}catch(i){return{severity:"error",error:i}}});function xe({result:e,elapsed:t}){let r=`${(t/1e3).toFixed(2)}s`;switch(e.severity){case"success":return`${Y.cyanBright("Built HTML documentation")} ${Y.greenBright("successfully")} in ${r}`;case"warn":return Y.yellowBright(e.error);case"error":return`${Y.redBright("Failed")} ${Y.cyanBright("to build HTML documentation: ")} ${e.error}`}}var he=()=>new xt("html").addOption(h).addOption(U).addOption(P).option("-v, --verbose").action(async e=>{let t=await k(e.manifest,null,[],!1),r=await j(t.bundles,e.srcDir,e.verbose,!1),n=await ee(t,e.outDir,r);console.log(xe(n)),n.result.severity==="error"&&process.exit(1)});import V from"chalk";import{loadESLint as vt}from"eslint";import{Command as ht}from"@commander-js/extra-typings";function me(e,t){return new ht(e).description(t).addOption(h).addOption(P).addOption(O).addOption(L)}function pe(e,t){return async r=>{console.log(te(r,{}));let n=await e(r),i=t(n);console.log(i),n.result.severity==="error"&&process.exit(1)}}var fe=z(async({bundles:e,tabs:t,srcDir:r,fix:n})=>{let i=await vt({useFlatConfig:!0}),o=new i({fix:n}),s=[...e.map(a=>`${r}/bundles/${a}/**/*.ts`),...t.map(a=>`${r}/tabs/${a}/**/*.ts*`)];try{let a=await o.lintFiles(s);n&&await i.outputFixes(a);let l=await(await o.loadFormatter("stylish")).format(a),b=K(a,({warningCount:m,errorCount:x,fatalErrorCount:$})=>!n&&$+x>0||n&&$>0?"error":m>0?"warn":"success");return{formatted:l,severity:b}}catch(a){return{severity:"error",formatted:a.toString()}}});function ve({elapsed:e,result:{formatted:t,severity:r}}){let n;return r==="error"?n=V.cyanBright("with ")+V.redBright("errors"):r==="warn"?n=V.cyanBright("with ")+V.yellowBright("warnings"):n=V.greenBright("successfully"),`${V.cyanBright(`Linting completed in ${q(e,1e3)}s ${n}:`)}
${t}`}var Tt=pe((...e)=>fe(...e),ve);function Ve(){return me("lint","Run eslint").addOption(ce).action(async e=>{let t=await k(e.manifest,e.bundles,e.tabs,!1);await Tt({...e,...t})})}import Bt from"fs/promises";import Ke from"path";import Q from"chalk";import Z from"typescript";async function Rt(e){let t=Ke.join(e,"tsconfig.json");try{let r=await Bt.readFile(t,"utf-8"),{error:n,config:i}=Z.parseConfigFileTextToJson(t,r);if(n)return{severity:"error",results:[n]};let{errors:o,options:s}=Z.parseJsonConfigFileContent(i,Z.sys,e);return o.length>0?{severity:"error",results:o}:{severity:"success",results:s}}catch(r){return{severity:"error",error:r}}}var ge=z(async({bundles:e,tabs:t,srcDir:r})=>{let n=await Rt(r);if(n.severity==="error")return n;let i=[];e.length>0&&A(r,e).forEach(o=>i.push(o)),t.length>0&&G(r,t).forEach(o=>i.push(o));try{let o=Z.createProgram(i,n.results),s=o.emit(),a=Z.getPreEmitDiagnostics(o).concat(s.diagnostics);return{severity:a.length>0?"error":"success",results:a}}catch(o){return{severity:"error",error:o}}});function Te({elapsed:e,result:t}){if(t.severity==="error"&&t.error)return`${Q.cyanBright(`tsc finished with ${Q.redBright("errors")} in ${q(e,1e3)}s: ${t.error}`)}`;let r=Z.formatDiagnosticsWithColorAndContext(t.results,{getNewLine:()=>`
`,getCurrentDirectory:()=>process.cwd(),getCanonicalFileName:n=>Ke.basename(n)});return t.severity==="error"?`${r}
${Q.cyanBright(`tsc finished with ${Q.redBright("errors")} in ${q(e,1e3)}s`)}`:`${r}
${Q.cyanBright(`tsc completed ${Q.greenBright("successfully")} in ${q(e,1e3)}s`)}`}var Ot=pe((...e)=>ge(...e),Te),qe=()=>me("tsc","Run the typescript compiler to perform type checking").action(async e=>{let t=await k(e.manifest,e.bundles,e.tabs,!0);await Ot({...e,...t})});async function Be(e,t,{tsc:r,lint:n,...i}){let o={...i,bundles:e,tabs:t};if(r){if(!n){let l=await ge(o);return{tsc:l,severity:l.result.severity}}let[s,a]=await p(ge(o),fe(o)),d=K([s,a],({result:{severity:l}})=>l);return{tsc:s,lint:a,severity:d}}if(n){let s=await fe(o);return{lint:s,severity:s.result.severity}}return null}function Qe(e){let t=[];if(e.tsc&&t.push(Te(e.tsc)),e.lint){let r=ve(e.lint);t.push(r)}return t.length>0?t.join(`
`):null}var kt=e=>e.severity==="success",Ze=e=>e.severity==="warn";function K(e,t){let r="success";for(let n of e){let i;if("severity"in n)i=n.severity;else{if(!t)throw new Error(`Mapping function required to convert ${n} to severity`);i=t(n)}if(i==="error")return"error";i==="warn"&&(r="warn")}return r}var A=(e,t)=>t.map(r=>`${e}/bundles/${r}/index.ts`),G=(e,t)=>t.map(r=>`${e}/tabs/${r}/index.tsx`),q=(e,t)=>(e/t).toFixed(2);function re(e,t,r){let n=s=>s.severity!=="success",i=Je(e).map(([s,a])=>{if(s==="html")return[a.result.severity,xe(a)];let d=K(a),l=s[0].toUpperCase()+s.slice(1);if(!t)return d==="success"?["success",`${c.cyanBright(`${l} built`)} ${c.greenBright("successfully")}
`]:d==="warn"?["warn",c.cyanBright(`${l} built with ${c.yellowBright("warnings")}:
${a.filter(Ze).map(({name:m,error:x},$)=>c.yellowBright(`${$+1}. ${m}: ${x}`)).join(`
`)}
`)]:["error",c.cyanBright(`${l} build ${c.redBright("failed")} with errors:
${a.filter(n).map(({name:m,error:x,severity:$},f)=>$==="error"?c.redBright(`${f+1}. Error ${m}: ${x}`):c.yellowBright(`${f+1}. Warning ${m}: ${x}`)).join(`
`)}
`)];let b=new Pt({columns:[{name:"name",title:l},{name:"severity",title:"Status"},{name:"error",title:"Errors"}]});return a.forEach(m=>{Ze(m)?b.addRow({...m,severity:"Warning"},{color:"yellow"}):kt(m)?b.addRow({...m,error:"-",severity:"Success"},{color:"green"}):b.addRow({...m,severity:"Error"},{color:"red"})}),d==="success"?["success",`${c.cyanBright(`${l} built`)} ${c.greenBright("successfully")}:
${b.render()}
`]:d==="warn"?["warn",`${c.cyanBright(`${l} built`)} with ${c.yellowBright("warnings")}:
${b.render()}
`]:["error",`${c.cyanBright(`${l} build ${c.redBright("failed")} with errors`)}:
${b.render()}
`]});console.log(i.map(s=>s[1]).join(`
`));let o=K(i,([s])=>s);return o==="error"&&r&&process.exit(1),o}function te({bundles:e,tabs:t},{tsc:r,lint:n},i){let o=[];return r&&o.push(c.yellowBright("--tsc specified, will run typescript checker")),n&&o.push(c.yellowBright("Linting specified, will run ESlint")),i!=="bundles"&&e.length>0&&(o.push(c.magentaBright("Processing the following bundles:")),e.forEach((s,a)=>o.push(`${a+1}. ${s}`))),i!=="tabs"&&t.length>0&&(o.push(c.magentaBright("Processing the following tabs:")),t.forEach((s,a)=>o.push(`${a+1}. ${s}`))),o.join(`
`)}function v(e,t){return async r=>{let n;switch(t){case"bundles":{n=await ze(r.manifest,r.tabs);break}case"tabs":{n=await Ue(r.manifest,r.bundles);break}case void 0:{n=await k(r.manifest,r.bundles,r.tabs);break}}console.log(te(n,r,t));let i=await Be(n.bundles,n.tabs,{lint:r.lint,fix:r.fix,tsc:r.tsc,srcDir:r.srcDir});if(i!==null){let s=Qe(i);console.log(s),i.severity==="error"&&process.exit(1)}let o=await e(n,r);re(o,r.verbose,!0),await Ct(r.manifest,`${r.outDir}/modules.json`)}}function C(e,t){return new $t(e).description(t).addOption(h).addOption(U).addOption(We).addOption(ce).addOption(P).option("--tsc","Run tsc before building")}import Xe from"fs/promises";import*as ne from"typedoc";var Re=e=>{var t=/</g,r=/>/g,n=/\t|\r|\uf8ff/g,i=/\\([\\\|`*_{}\[\]()#+\-~])/g,o=/^([*\-=_] *){3,}$/gm,s=/\n *&gt; *([^]*?)(?=(\n|$){2})/g,a=/\n( *)(?:[*\-+]|((\d+)|([a-z])|[A-Z])[.)]) +([^]*?)(?=(\n|$){2})/g,d=/<\/(ol|ul)>\n\n<\1>/g,l=/(^|[^A-Za-z\d\\])(([*_])|(~)|(\^)|(--)|(\+\+)|`)(\2?)([^<]*?)\2\8(?!\2)(?=\W|_|$)/g,b=/\n((```|~~~).*\n?([^]*?)\n?\2|(( {4}.*?\n)+))/g,m=/((!?)\[(.*?)\]\((.*?)( ".*")?\)|\\([\\`*_{}\[\]()#+\-.!~]))/g,x=/\n(( *\|.*?\| *\n)+)/g,$=/^.*\n( *\|( *\:?-+\:?-+\:? *\|)* *\n|)/,f=/.*\n/g,N=/\||(.*?[^\\])\|/g,mt=/(?=^|>|\n)([>\s]*?)(#{1,6}) (.*?)( #*)? *(?=\n|$)/g,pt=/(?=^|>|\n)\s*\n+([^<]+?)\n+\s*(?=\n|<|$)/g,ft=/-\d+\uf8ff/g;function T(u,g){e=e.replace(u,g)}function B(u,g){return"<"+u+">"+g+"</"+u+">"}function Le(u){return u.replace(s,function(g,w){return B("blockquote",Le(H(w.replace(/^ *&gt; */gm,""))))})}function _e(u){return u.replace(a,function(g,w,y,R,X,I){var J=B("li",H(I.split(RegExp(`
 ?`+w+"(?:(?:\\d+|[a-zA-Z])[.)]|[*\\-+]) +","g")).map(_e).join("</li><li>")));return`
`+(y?'<ol start="'+(R?y+'">':parseInt(y,36)-9+'" style="list-style-type:'+(X?"low":"upp")+'er-alpha">')+J+"</ol>":B("ul",J))})}function H(u){return u.replace(l,function(g,w,y,R,X,I,J,gt,Fe,yt){return w+B(R?Fe?"strong":"em":X?Fe?"s":"sub":I?"sup":J?"small":gt?"big":"code",H(yt))})}function le(u){return u.replace(i,"$1")}var we=[],ue=0;return e=`
`+e+`
`,T(t,"&lt;"),T(r,"&gt;"),T(n,"  "),e=Le(e),T(o,"<hr/>"),e=_e(e),T(d,""),T(b,function(u,g,w,y,R){return we[--ue]=B("pre",B("code",y||R.replace(/^ {4}/gm,""))),ue+"\uF8FF"}),T(m,function(u,g,w,y,R,X,I){return we[--ue]=R?w?'<img src="'+R+'" alt="'+y+'"/>':'<a href="'+R+'">'+le(H(y))+"</a>":I,ue+"\uF8FF"}),T(x,function(u,g){var w=g.match($)[1];return`
`+B("table",g.replace(f,function(y,R){return y==w?"":B("tr",y.replace(N,function(X,I,J){return J?B(w&&!R?"th":"td",le(H(I||""))):""}))}))}),T(mt,function(u,g,w,y){return g+B("h"+w.length,le(H(y)))}),T(pt,function(u,g){return B("p",le(H(g)))}),T(ft,function(u){return we[parseInt(u)]}),e.trim()};var Oe=e=>e.stringify(ne.TypeContext.none),jt={[ne.ReflectionKind.Function](e){let[t]=e.signatures,r;t.comment?r=Re(t.comment.summary.map(({text:i})=>i).join("")):r="No description available";let n=t.parameters.map(({type:i,name:o})=>[o,Oe(i)]);return{kind:"function",name:e.name,description:r,params:n,retType:Oe(t.type)}},[ne.ReflectionKind.Variable](e){let t;return e.comment?t=Re(e.comment.summary.map(({text:r})=>r).join("")):t="No description available",{kind:"variable",name:e.name,description:t,type:Oe(e.type)}}};async function Ge(e,t,r){try{let n=t.children.reduce((i,o)=>{let s=jt[o.kind];return{...i,[o.name]:s?s(o):{kind:"unknown"}}},{});return await Xe.writeFile(`${r}/jsons/${e}.json`,JSON.stringify(n,null,2)),{name:e,severity:"success"}}catch(n){return{name:e,severity:"error",error:n}}}var ie=async({bundles:e},t,r)=>{if(await Xe.mkdir(`${t}/jsons`,{recursive:!0}),e.length===1){let[i]=e;return{jsons:[await Ge(i,r,t)]}}return{jsons:await Promise.all(e.map(i=>Ge(i,r.getChildByName(i),t)))}},St=v(async(e,{srcDir:t,outDir:r,verbose:n})=>{let[i]=await j(e.bundles,t,n,!1);return ie(e,r,i)},"tabs"),Ce=()=>C("jsons","Build json documentation").addOption(O).action(e=>St({...e,tabs:[]}));async function $e(e,t,r){let[n,i]=await Promise.all([ie(e,t,r[0]),ee(e,t,r)]);return{...n,html:i}}var Et=v(async(e,{srcDir:t,outDir:r,verbose:n})=>{let i=await j(e.bundles,t,n,!1);return $e(e,r,i)},"tabs"),Ye=()=>C("docs","Build HTML and json documentation").addOption(O).action(e=>Et({...e,tabs:[]}));import It from"fs/promises";import{build as Lt}from"esbuild";import Dt from"fs/promises";import At from"path";import{parse as Mt}from"acorn";import{generate as Nt}from"astring";var M={bundle:!0,format:"iife",define:{process:JSON.stringify({env:{NODE_ENV:"production"}})},external:["js-slang*"],globalName:"module",platform:"browser",target:"es6",write:!1};async function _({path:e,text:t},r){let[n,i]=e.split(At.sep).slice(-3,-1),o=null;try{let s=Mt(t,{ecmaVersion:6}),a;s.body[0].type==="VariableDeclaration"?a=s.body[0]:a=s.body[1];let m={type:"ExportDefaultDeclaration",declaration:{...a.declarations[0].init.callee,params:[{type:"Identifier",name:"require"}]}};o=await Dt.open(`${r}/${n}/${i}.js`,"w");let x=o.createWriteStream();return Nt(m,{output:x}),{severity:"success",name:i}}catch(s){return{name:i,severity:"error",error:s}}finally{await o?.close()}}var Ht=["js-slang","js-slang/context","js-slang/dist/cse-machine/interpreter","js-slang/dist/stdlib","js-slang/dist/stdlib/list","js-slang/dist/stdlib/misc","js-slang/dist/stdlib/stream","js-slang/dist/types","js-slang/dist/utils/assert","js-slang/dist/utils/stringify","js-slang/dist/parser/parser"],F={name:"js-slang import checker",setup(e){e.onResolve({filter:/^js-slang/u},t=>{if(!Ht.includes(t.path))return{errors:[{text:"This export from js-slang is not supported!"}]}})}},ye={name:"Assert Polyfill",setup(e){e.onResolve({filter:/^assert/u},()=>({path:"assert",namespace:"bundleAssert"})),e.onLoad({filter:/^assert/u,namespace:"bundleAssert"},()=>({contents:`
      export default function assert(condition, message) {
        if (condition) return;

        if (typeof message === 'string' || message === undefined) {
          throw new Error(message);
        }

        throw message;
      }
      `}))}};var Pe=async({bundles:e},{srcDir:t,outDir:r})=>{let[{outputFiles:n}]=await p(Lt({...M,entryPoints:A(t,e),outbase:r,outdir:r,plugins:[ye,F],tsconfig:`${t}/tsconfig.json`}),It.mkdir(`${r}/bundles`,{recursive:!0}));return{bundles:await Promise.all(n.map(o=>_(o,r)))}},_t=v((...e)=>Pe(...e)),ke=()=>C("bundles","Build bundles").addOption(O).action(e=>_t({...e,tabs:[]}));import Ft from"fs/promises";import{build as Wt}from"esbuild";var je={name:"Tab Context",setup(e){e.onResolve({filter:/^js-slang\/context/u},()=>({errors:[{text:"If you see this message, it means that your tab code is importing js-slang/context directly or indirectly. Do not do this"}]}))}},Se=async({tabs:e},{srcDir:t,outDir:r})=>{let[{outputFiles:n}]=await p(Wt({...M,entryPoints:G(t,e),external:[...M.external,"react","react-ace","react-dom","react/jsx-runtime","@blueprintjs/*"],jsx:"automatic",outbase:r,outdir:r,tsconfig:`${t}/tsconfig.json`,plugins:[je,F]}),Ft.mkdir(`${r}/tabs`,{recursive:!0}));return{tabs:await Promise.all(n.map(o=>_(o,r)))}},Jt=v((...e)=>Se(...e),"bundles"),Ee=()=>C("tabs","Build tabs").addOption(L).action(e=>Jt({...e,bundles:[]}));var De=async(e,t)=>{let[r,n]=await Promise.all([Pe(e,t),Se(e,t)]);return{...r,...n}},In=v(De);import oe from"fs/promises";import{Command as Ut}from"@commander-js/extra-typings";import se from"chalk";import{context as et}from"esbuild";var zt=()=>new Promise((e,t)=>{process.stdin.setRawMode(!0),process.stdin.on("data",r=>{let n=[...r];n.length>0&&n[0]===3&&(console.log("^C"),process.stdin.setRawMode(!1),e())}),process.stdin.on("error",t)});function Ae(){return new Ut("watch").description("Watch the source directory and rebuild on changes").addOption(h).addOption(U).addOption(P).option("-v, --verbose").action(async e=>{let[t]=await p(k(e.manifest,null,null),oe.mkdir(e.outDir).then(()=>oe.copyFile(e.manifest,`${e.outDir}/modules.json`)));console.log(te(t,{}));let r=null,n=null;try{await p(oe.mkdir(`${e.outDir}/bundles`),oe.mkdir(`${e.outDir}/tabs`),oe.mkdir(`${e.outDir}/jsons`)),[r,n]=await p(et({...M,entryPoints:A(e.srcDir,t.bundles),outbase:e.outDir,outdir:e.outDir,plugins:[ye,F,{name:"Bundles output",setup(i){i.onStart(()=>{console.log(se.magentaBright("Beginning bundles build..."))}),i.onEnd(async({outputFiles:o})=>{let s=await Promise.all(o.map(a=>_(a,e.outDir)));re({bundles:s},e.verbose,!1)})}}],tsconfig:`${e.srcDir}/tsconfig.json`}),et({...M,entryPoints:G(e.srcDir,t.tabs),outbase:e.outDir,outdir:e.outDir,plugins:[je,F,{name:"Tabs output",setup(i){i.onStart(()=>{console.log(se.magentaBright("Beginning tabs build..."))}),i.onEnd(async({outputFiles:o})=>{let s=await Promise.all(o.map(a=>_(a,e.outDir)));re({tabs:s},e.verbose,!1)})}}],tsconfig:`${e.srcDir}/tsconfig.json`}),j(t.bundles,e.srcDir,e.verbose,!0).then(([,i])=>{i.convertAndWatch(async o=>{let[s,a]=await p(ie(t,e.outDir,o),ee(t,e.outDir,[o,i]));re({...s,html:a},e.verbose,!1)})})),console.log(se.yellowBright(`Watching ${se.cyanBright(`./${e.srcDir}`)} for changes
Press CTRL + C to stop`)),await zt(),console.log(se.yellowBright("Quitting!")),await p(r.cancel(),n.cancel())}finally{await p(r?.dispose(),n?.dispose())}process.exit()})}var Kt=async(e,t)=>{let r=await j(e.bundles,t.srcDir,t.verbose,!1),[n,i]=await Promise.all([De(e,t),$e(e,t.outDir,r)]);return{...n,...i}},qt=v(Kt),Qt=()=>C("all","Build bundles and tabs and documentation").addOption(O).addOption(L).action(qt),Zt=()=>new Vt("build").addCommand(Qt(),{isDefault:!0}).addCommand(ke()).addCommand(Ye()).addCommand(he()).addCommand(Ce()).addCommand(Ee()).addCommand(Ae()),tt=Zt;import{Command as ir}from"@commander-js/extra-typings";import Me from"fs/promises";import{createInterface as Gt}from"readline/promises";import ae from"chalk";var rt=()=>Gt({input:process.stdin,output:process.stdout});function nt(...e){return console.log(...e.map(t=>ae.grey(t)))}function it(...e){return console.log(...e.map(t=>ae.red(t)))}function E(...e){return console.log(...e.map(t=>ae.yellow(t)))}function be(...e){return console.log(...e.map(t=>ae.green(t)))}function W(e,t){return t.question(ae.blueBright(`${e}
`))}var Xt=/\b[a-z0-9]+(?:_[a-z0-9]+)*\b/u,Yt=/^[A-Z][a-z]+(?:[A-Z][a-z]+)*$/u;function ot(e){return Xt.test(e)}function st(e){return Yt.test(e)}var Ne=(e,t)=>Object.keys(e).includes(t);async function er(e,t){for(;;){let r=await W("What is the name of your new module? (eg. binary_tree)",t);if(ot(r)===!1)E("Module names must be in snake case. (eg. binary_tree)");else if(Ne(e,r))E("A module with the same name already exists.");else return r}}async function at({srcDir:e,manifest:t},r){let n=await D(t),i=await er(n,r),o=`${e}/bundles/${i}`;await Me.mkdir(o,{recursive:!0}),await p(Me.copyFile("./scripts/src/templates/templates/__bundle__.ts",`${o}/index.ts`),Me.writeFile(t,JSON.stringify({...n,[i]:{tabs:[]}},null,2))),be(`Bundle for module ${i} created at ${o}.`)}import He from"fs/promises";function tr(e,t){return Object.values(e).flatMap(r=>r.tabs).includes(t)}async function rr(e,t){for(;;){let r=await W("Add a new tab to which module?",t);if(!Ne(e,r))E(`Module ${r} does not exist.`);else return r}}async function nr(e,t){for(;;){let r=await W("What is the name of your new tab? (eg. BinaryTree)",t);if(tr(e,r))E("A tab with the same name already exists.");else if(!st(r))E("Tab names must be in pascal case. (eg. BinaryTree)");else return r}}async function lt({manifest:e,srcDir:t},r){let n=await D(e),i=await rr(n,r),o=await nr(n,r),s=`${t}/tabs/${o}`;await He.mkdir(s,{recursive:!0}),await p(He.copyFile("./scripts/src/templates/templates/__tab__.tsx",`${s}/index.tsx`),He.writeFile(e,JSON.stringify({...n,[i]:{tabs:[...n[i].tabs,o]}},null,2))),be(`Tab ${o} for module ${i} created at ${s}.`)}async function or(e){for(;;){let t=await W("What would you like to create? (module/tab)",e);if(t!=="module"&&t!=="tab")E("Please answer with only 'module' or 'tab'.");else return t}}function Ie(){return new ir("template").addOption(h).addOption(P).description("Interactively create a new module or tab").action(async e=>{let t=rt();try{let r=await or(t);r==="module"?await at(e,t):r==="tab"&&await lt(e,t)}catch(r){it(`ERROR: ${r.message}`),nt("Terminating module app...")}finally{t.close()}})}import ct from"path";import{Command as lr}from"@commander-js/extra-typings";import ur from"lodash";import sr from"path";import ar from"jest";function ut(e,t){return ar.run(e,sr.join(t,"jest.config.js"))}var cr=()=>new lr("test").description("Run jest").addOption(h).allowUnknownOption().action(({srcDir:e},t)=>{let[r,n]=ur.partition(t.args,s=>s.startsWith("-")),i=r.findIndex(s=>s.startsWith("--srcDir"));i!==-1&&r.splice(i,1);let o=r.concat(n.map(s=>s.split(ct.win32.sep).join(ct.posix.sep)));return ut(o,e)}),dt=cr;await new dr("scripts").addCommand(tt()).addCommand(Ve()).addCommand(dt()).addCommand(qe()).addCommand(Ie()).parseAsync();
