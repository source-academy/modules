import{_ as t,c as o,o as i,a2 as n}from"./chunks/framework.BYVJ-AET.js";const u=JSON.parse('{"title":"Prebuild Tasks","description":"","frontmatter":{},"headers":[],"relativePath":"buildtools/6-prebuild.md","filePath":"buildtools/6-prebuild.md","lastUpdated":1770449117000}'),a={name:"buildtools/6-prebuild.md"};function r(s,e,c,d,l,h){return i(),o("div",null,e[0]||(e[0]=[n('<h1 id="prebuild-tasks" tabindex="-1">Prebuild Tasks <a class="header-anchor" href="#prebuild-tasks" aria-label="Permalink to &quot;Prebuild Tasks&quot;">​</a></h1><p>There are two &quot;prebuild&quot; tasks, linting and type checking that need to be run before any kind of building takes place.</p><p>The buildtools call both ESLint and <code>tsc</code> in parallel since they are not dependent on each others&#39; outputs.</p><h2 id="running-eslint-from-the-command-line" tabindex="-1">Running ESLint from the Command Line <a class="header-anchor" href="#running-eslint-from-the-command-line" aria-label="Permalink to &quot;Running ESLint from the Command Line&quot;">​</a></h2><p>ESLint provides <a href="https://eslint.org/docs/latest/integrate/nodejs-api" target="_blank" rel="noreferrer">documentation</a> detailing how to use its Node API.</p><p>Because the configuration file for the repository is located at the root of the repository, we need to set the <code>cwd</code> to the path to the root of the repository when initializing the <code>ESLint</code> instance. This allows ESLint to resolve the configuration correctly.</p><p>Linting warnings and errors come in two types, fixable and non-fixable. Fixable errors don&#39;t cause a non-zero exit code when ESLint is run with <code>--fix</code>, while non-fixable errors always cause a non-zero exit code.</p><p>ESLint provides several <a href="https://eslint.org/docs/latest/use/formatters/" target="_blank" rel="noreferrer">formatters</a> for processing the results objects it returns. To produce the human readable output that is printed to the command line, the <code>stylish</code> formatter is loaded and used.</p><div class="tip custom-block github-alert"><p class="custom-block-title">Inspecting the Linting Config</p><p>The entire repository&#39;s linting configuration is located at the root of the repository within <code>eslint.config.js</code>. If you want to view the view what rules are being applied to which files you can use the config inspector, which can be started using <code>yarn lint:inspect</code></p></div><p>When run with the <a href="https://eslint.org/docs/latest/extend/stats#cli-usage" target="_blank" rel="noreferrer"><code>--stats</code></a> option, the collected stats will be written to the output directory under the <code>lintstats</code> folder.</p><details class="details custom-block"><summary>Out of Memory Error</summary><p>As of the time of writing, spinning up a single ESLint instance to lint all the files in the repository at once seems to cause ESLint/NodeJS to run out of memory. A lot of the tooling has been designed to seamlessly bypass this issue by linting each bundle and tab with a separate instance of ESLint, but this does mean that we also need specific tooling for linting the rest of the repository.</p><p>That&#39;s why there&#39;s a <code>lint</code> command and also a <code>lintglobal</code> command.</p></details><h2 id="calling-typescript-from-node" tabindex="-1">Calling Typescript from Node <a class="header-anchor" href="#calling-typescript-from-node" aria-label="Permalink to &quot;Calling Typescript from Node&quot;">​</a></h2><p>Most of the code for running Typescript functionality from Node was taken from <a href="https://github.com/Microsoft/TypeScript/issues/6387" target="_blank" rel="noreferrer">this</a> Github issue.</p><p>The high level overview of this process is as follows:</p><ol><li>Read the raw text from the <code>tsconfig.json</code></li><li>Parse the <code>tsconfig.json</code> into a JSON object using <code>ts.parseConfigFileTextToJson</code></li><li>Parse the JSON object into actual compiler options using <code>ts.parseJsonConfigFileContent</code>. This also returns an array of file names for parsing.</li><li>Use <code>ts.createProgram</code> to get the preliminary program for type checking only.</li><li>Call <code>typecheckProgram.emit()</code> to produce the typechecking results.</li><li>Combine the results with <code>ts.getPreEmitDiagonstics</code>.</li><li>If there were no typechecking errors use <code>ts.createProgram</code> again with the typecheck program to perform compilation and declaration file emission excluding test files by manually setting <code>noEmit</code> to <code>false</code>.</li><li>Format the diagnostic objects using <code>ts.formatDiagnosticsWithColorAndContext</code></li></ol><h3 id="reading-and-parsing-tsconfig-json" tabindex="-1">Reading and Parsing <code>tsconfig.json</code> <a class="header-anchor" href="#reading-and-parsing-tsconfig-json" aria-label="Permalink to &quot;Reading and Parsing `tsconfig.json`&quot;">​</a></h3><p>The first three steps in the process involve reading the raw text from the <code>tsconfig.json</code> and then parsing it. At the end of it, <code>ts.parseJsonConfigFileContent</code> resolves all the inherited options and produces the compiler options in use, as well as the file paths to the files that are to be processed.</p><h3 id="type-checking" tabindex="-1">Type Checking <a class="header-anchor" href="#type-checking" aria-label="Permalink to &quot;Type Checking&quot;">​</a></h3><p>At step 4, <code>ts.createProgram</code> is called for the first time. It is called with every single file as returned from <code>ts.parseJsonConfigFileContent</code>. However, it is called with <code>noEmit: true</code>. This prevents any Javascript and Typescript declaration files from being written. This is important because we want test files to be type checked, but we don&#39;t want them to be compiled into Javascript and exported with the rest of the code. If they were included and the <code>tsconfig</code> was configured to produce outputs, the test files would end up being written to the <code>outDir</code>. <code>typecheckProgram.emit</code> is called to perform the type checking.</p><p>If there are no errors and the <code>tsconfig</code> was configured to produce outputs, <code>ts.createProgram</code> is called again. This time, test files are filtered out. <code>ts.createProgram</code> has a parameter for passing in the previous program object, allowing it to reuse an existing program so it doesn&#39;t have to reinitialize the entire object again. <code>program.emit</code> is called to produce any compiled Javascript and Typescript declaration files.</p>',20)]))}const f=t(a,[["render",r]]);export{u as __pageData,f as default};
