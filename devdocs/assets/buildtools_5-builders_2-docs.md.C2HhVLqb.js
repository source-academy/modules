import{_ as o,c as t,o as n,a2 as a}from"./chunks/framework.BYVJ-AET.js";const u=JSON.parse('{"title":"Documentation Generation","description":"","frontmatter":{},"headers":[],"relativePath":"buildtools/5-builders/2-docs.md","filePath":"buildtools/5-builders/2-docs.md","lastUpdated":1768233552000}'),r={name:"buildtools/5-builders/2-docs.md"};function s(d,e,c,i,l,h){return n(),t("div",null,e[0]||(e[0]=[a('<h1 id="documentation-generation" tabindex="-1">Documentation Generation <a class="header-anchor" href="#documentation-generation" aria-label="Permalink to &quot;Documentation Generation&quot;">​</a></h1><p>There are two types of documentation used by Source, which are the JSONs and the HTML documentation. Both are built using the <a href="https://typedoc.org" target="_blank" rel="noreferrer"><code>typedoc</code></a> tool. By reading comments and type annotations, <code>typedoc</code> is able to generate both human readable documentation and documentation in the form of JSON.</p><h2 id="typedoc-overview" tabindex="-1">Typedoc Overview <a class="header-anchor" href="#typedoc-overview" aria-label="Permalink to &quot;Typedoc Overview&quot;">​</a></h2><p>Documentation generation is a two-step process:</p><p>Firstly, the <code>buildtools build docs</code> is called on each bundle. This produces two JSON files:</p><ol><li><code>build/jsons/[bundle_name].json</code>, which is the JSON documentation used by <code>js-slang</code> and the frontend</li><li><code>docs.json</code>, which is JSON documentation format used by <code>typedoc</code> to generate the HTML documentation later</li></ol><p>Second, <code>buildtools manifest</code> is called, which then takes the <code>docs.json</code> files from each bundle and uses the <a href="https://typedoc.org/documents/Options.Input.html#merge" target="_blank" rel="noreferrer"><code>merge</code> entry point strategy</a> to create the HTML documentation</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p>Since type checking is supposed to be performed by <code>tsc</code>, <code>skipErrorChecking</code> has been set to true. This means that if there are type errors in the source files being processed, <code>typedoc</code> simply returns <code>undefined</code> when <code>Application.convert</code> is called.</p></div><p>This allows each bundle to have its own Typedoc option set.</p><h2 id="html-generation" tabindex="-1">HTML Generation <a class="header-anchor" href="#html-generation" aria-label="Permalink to &quot;HTML Generation&quot;">​</a></h2><p>It is not possible to generate the HTML documentation on a per-bundle basis. Thus, when HTML documentation needs to be regenerated, the source files of every single bundle needs to be processed.</p><h2 id="json-generation" tabindex="-1">JSON Generation <a class="header-anchor" href="#json-generation" aria-label="Permalink to &quot;JSON Generation&quot;">​</a></h2><p><code>typedoc</code> represents each bundle as a <a href="https://typedoc.org/api/classes/Models.DeclarationReflection.html" target="_blank" rel="noreferrer"><code>DeclarationReflection</code></a> internally. Each of these <code>DeclarationReflection</code>s contains an array of &quot;children&quot; elements which represents that bundle&#39;s exports. Each of these elements is parsed by various parsers to produce the desired documentation object, which is then written to disk after converted into a JSON string.</p>',13)]))}const m=o(r,[["render",s]]);export{u as __pageData,m as default};
